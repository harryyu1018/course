## 4. 引入流

集合是Java中使用最多的API。几乎每个Java应用程序都会制造和处理集合。集合对于很多的编程任务来说都是非常基本的。目前集合的不完美：

- 不能类似SQL只需表达你想要什么？
- 处理大量元素比较困难



> 流式Java API的新成员，它允许你以声明性方式处理数据集合（通过查询语句来表达，而不是临时编写一个实现）。



### 4.1 简介 

- 元素序列
- 源
- 数据处理操作



**流操作的两个重点操作**

- 流水线：很多流操作本身会返回一个流，这样多个操作就可以链接起来，形成一个大的流水线。这样可以实现一些优化：如延迟和短路。
- 内部迭代：与使用迭代器显示迭代的集合不同，流的迭代操作是在背后进行的。





**流操作**

- 中间操作：可以连接起来的流操作
  - 如filter或sorted等中间操作会返回另一个流。这让多个操作可以连接起来形成一个查询。重要的是，除非流水线上触发一个终端操作，否则中间操作不会执行任何处理。
- 终端操作：关闭流的操作
  - 会从流的流水线生成结果。其结果是任何非流的值，比如List、Integer、甚至void。



流的使用一般包括三件事：

- 一个数据源（如集合）来执行一个查询
- 一个中间操作链，形成一条流的流水线
- 一个终端操作，执行流水线，并能生成结果



**思考**

> 流的流水线背后的原理类似于构建器模式。在构建器模式中有一个调用链来设置一套配置（对流来说这就是一个中间操作链），接着是调用built方法（对流来说就是终端操作了）。



## 5. 使用流

- 筛选、切片和匹配
- 查找、匹配和规约
- 使用数值范围等数值流
- 从多个源创建流
- 无限流



### 归约操作

用函数式编程语言的术语来说，这称为折叠（fold）。因为你可以将这个操作看成把一张长长的纸（流）反复折叠成一个小方块，而这就是折叠操作的结果。



**流操作：无状态和有状态**

> 诸如map或filter等操作会从输入流中获取每一个元素，并在输出流中得到0或1个结果。这些操作一般都是无状态的：它们没有内部状态。
>
> 诸如reduce、sum、max等操作需要内部状态来累积结果，但其内部状态是有界的。
>
> 相反，诸如sort和distinct等操作一开始都和filter、map差不多，都是接受一个流，再生成一个流（中间操作），但有一个关键区别。从流中排序和删除重复项目都需要知道先前的历史。要是流比较大或者无限，就可能出现问题。



### 构建流的方法

- 由值创建
- 由数组创建
- 由文件生成流
- 由函数生成流：创建无限流



```java
// 字符串流
Stream<String> stream = Stream.of("Java 8 ", "Lambda ", "In ", "Action ");

// 空流
Stream<String> emptyStream = Stream.empty();

// 数组创建
Arrays.stream(new int[] {2, 3, 5, 7, 11});

// 文件生成
Stream<String> lines = Files.lines(pathName, charset);

// iterate
Stream.iterate(0, n -> n + 2);

// generate
Stream.generate(Math::random);
```



## 6. 用流收集数据



### 6.1 收集器

预定义收集器：

- 将流元素归约和汇总为一个值
- 元素分组
- 元素分区





```java
public static <T> Collector<T, ?, Long> counting() {
  return reducing(0L, e -> 1L, Long::sum);
}
```



> **使用泛型？通配符**
>
> 上面的例子仅仅意味着收集器的累加器类型未知，换句话说，累加器本身可以是任何类型。



















